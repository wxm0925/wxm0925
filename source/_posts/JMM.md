---
title: JMM
category: JVM
tag: JMM
date: 2024/9/18 22:46:25
---

# JMM

Java 内存模型（Java Memory Model, JMM）定义了多线程环境下，Java 程序如何在内存中进行**变量读取和写入**的规则，以及不同线程之间如何**共享变量**。JMM 的主要目标是为开发者提供一致的行为，以便在多核系统上正确地进行并发编程。

### 1. **Java 内存模型的核心概念**
   - **主内存（Main Memory）**：所有的共享变量（实例变量、静态变量）都存储在主内存中。主内存是每个线程都可以访问的全局内存。
   - **工作内存（Working Memory）**：每个线程都有自己的工作内存，线程从主内存中拷贝共享变量的副本到自己的工作内存中进行操作。线程对变量的操作（如读取、写入）必须在自己的工作内存中进行，最终将修改后的值刷新到主内存。

### 2. **Java 内存模型的三大特性**

#### 2.1 **原子性**
   - 原子性保证了某些操作是不可分割的，即线程之间不会看到这些操作的中间状态。Java 提供的原子操作包括：
     - 基本类型的读取和写入（`long` 和 `double` 除外，因为它们可能涉及 64 位的拆分）。
     - `volatile` 修饰的变量的写入和读取操作也是原子的。

#### 2.2 **可见性**
   - 可见性是指当一个线程对变量进行了修改，其他线程是否能够立即看到修改的结果。JMM 规定，线程对共享变量的修改在没有特殊处理的情况下，其他线程可能无法立即看到。
   - **volatile** 关键字可以用来保证变量的可见性，所有对 `volatile` 变量的写操作都会立刻刷新到主内存，而对 `volatile` 变量的读操作会直接从主内存读取。

#### 2.3 **有序性**
   - 有序性指的是程序的执行顺序看起来和代码编写的顺序一致。但实际上，编译器和 CPU 会进行**指令重排序**以优化性能，导致程序实际执行顺序可能不同于代码顺序。
   - JMM 提供了 **happens-before** 规则来保证线程间的有序性：
     - 线程内的操作是按代码顺序执行的。
     - 一个线程释放锁的操作发生在后续获取同一个锁的操作之前。
     - 对 `volatile` 变量的写操作先发生于之后的读操作。

   **volatile** 除了保证可见性，还能防止指令重排序，以保证写入 `volatile` 变量之前的操作不会被重排到其后。

### 3. **happens-before 规则**
   happens-before 是 JMM 的一个核心规则，用于定义操作间的执行顺序。常见的 happens-before 规则包括：
   - **程序顺序规则**：在一个线程内，按照代码的顺序，前面的操作 happens-before 后面的操作。
   - **监视器锁规则**：解锁操作 happens-before 之后的加锁操作。
   - **volatile 规则**：对一个 `volatile` 变量的写操作 happens-before 任何线程之后对该变量的读操作。
   - **线程启动规则**：线程 `A` 启动线程 `B`，则在线程 `B` 开始之前，线程 `A` 所有的操作都对线程 `B` 可见。
   - **线程终止规则**：线程 `A` 结束，线程 `B` 可以通过 `Thread.join()` 等方法得知 `A` 的终止，此时 `A` 所有的操作对 `B` 可见。

### 4. **内存屏障**
JMM 通过**内存屏障（Memory Barriers, Fences）**来禁止特定的重排序，从而确保线程间的可见性和有序性。内存屏障分为以下几种：
   - **LoadLoad 屏障**：防止重排序 `Load1` 和 `Load2`，确保第一个 `Load` 操作读取的数据对后续读取操作可见。
   - **StoreStore 屏障**：防止重排序 `Store1` 和 `Store2`，确保第一个写操作完成后，第二个写操作才能执行。
   - **LoadStore 屏障**：防止重排序 `Load1` 和 `Store2`，确保第一个读取操作完成后才能执行写操作。
   - **StoreLoad 屏障**：防止重排序 `Store1` 和 `Load2`，确保第一个写操作的结果对后续的读取操作可见。

### 5. **常见并发问题**
   - **可见性问题**：线程对共享变量的修改对其他线程不可见，导致其他线程使用过期的数据。
   - **指令重排序问题**：由于编译器和 CPU 优化，可能导致代码执行顺序与预期不符，进而引发并发错误。
   - **竞态条件**：多个线程在没有适当同步的情况下同时访问和修改共享数据，导致不可预测的结果。

### 6. **线程安全的措施**
   - **volatile**：确保可见性和禁止指令重排序，但不保证原子性。
   - **synchronized**：保证原子性、可见性和有序性，通过监视器锁实现互斥。
   - **Lock**：Java 提供的高级锁机制，比如 `ReentrantLock`，支持更多的并发控制功能，如公平锁、可中断锁等。
   - **Atomic 类**：提供了一组基于 CAS（Compare-And-Swap）实现的原子操作类，如 `AtomicInteger`、`AtomicReference`，可以保证原子性和线程安全。

通过 Java 内存模型，开发者可以更好地理解并发编程的细节，从而设计出更高效和正确的多线程应用。